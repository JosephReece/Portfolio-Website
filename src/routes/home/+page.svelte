<script lang="ts">
  import { onMount } from "svelte";
  import { Canvas } from "@threlte/core";
  import { OrbitControls } from "@threlte/extras";
  import { T } from "@threlte/core";
  import { cubicInOut } from "svelte/easing";
  import { Tween } from "svelte/motion";

  // Array of objects with models and their descriptions
  const items = [
    {
      name: "3D Square",
      description:
        "A simple geometric primitive with six square faces. Cubes are foundational shapes in 3D modeling and are often used as building blocks for more complex structures.",
      model: "Box",
      color: "#6A7FDB",
    },
    {
      name: "Sphere",
      description:
        "A perfectly round geometrical object. Spheres are commonly used in 3D graphics for planets, balls, or any rounded object that needs to appear smooth from all angles.",
      model: "Sphere",
      color: "#45CB85",
    },
    {
      name: "Torus",
      description:
        "A donut-shaped surface of revolution generated by revolving a circle in three-dimensional space. Torus shapes are used for rings, tubes, and complex knot structures.",
      model: "Torus",
      color: "#F06449",
    },
    {
      name: "Cylinder",
      description:
        "A three-dimensional solid consisting of two parallel circular bases connected by a curved surface. Cylinders are used to represent pipes, columns, and various mechanical parts.",
      model: "Cylinder",
      color: "#EFB5CB",
    },
    {
      name: "Cone",
      description:
        "A three-dimensional geometric shape that tapers smoothly from a flat circular base to a point. Cones are often used to create pointed structures like ice cream cones or party hats.",
      model: "Cone",
      color: "#FFE74C",
    },
  ];

  // State variables
  let scrollY = 0;
  let windowHeight = 0;

  // Use a tweened value for smooth transitions
  const indexTween = new Tween(0, {
    duration: 40,
    easing: cubicInOut,
  });

  onMount(() => {
    // Add scroll listener to update scrollY
    const handleScroll = () => {
      scrollY = window.scrollY;
      // Calculate the index based on scroll position and window height
      indexTween.set(scrollY / windowHeight);
    };

    window.addEventListener("scroll", handleScroll);

    // Cleanup
    return () => {
      window.removeEventListener("scroll", handleScroll);
    };
  });
</script>

<svelte:window bind:scrollY bind:innerHeight={windowHeight} />

<div class="container">
  <div class="model-container">
    <div class="canvas-container">
      <Canvas>
        <T.PerspectiveCamera makeDefault position={[5, 5, 5]}>
          <OrbitControls
            onchange={(e) => {
              console.log(e.target.object.position);
            }}
          />
        </T.PerspectiveCamera>

        <T.DirectionalLight position={[3, 10, 10]} intensity={1.5} />
        <T.AmbientLight intensity={0.5} />

        <T.Group>
          {#each items as item, i}
            <T.Group position={[0, (i - indexTween.current) * 7.5, 0]}>
              {#if item.model === "Box"}
                <T.Mesh rotation={[0.5, 0.5, 0]}>
                  <T.BoxGeometry args={[1, 1, 1]} />
                  <T.MeshStandardMaterial color={item.color} />
                </T.Mesh>
              {:else if item.model === "Sphere"}
                <T.Mesh>
                  <T.SphereGeometry args={[0.8, 32, 32]} />
                  <T.MeshStandardMaterial color={item.color} />
                </T.Mesh>
              {:else if item.model === "Torus"}
                <T.Mesh rotation={[Math.PI / 4, 0, 0]}>
                  <T.TorusGeometry args={[0.6, 0.2, 16, 50]} />
                  <T.MeshStandardMaterial color={item.color} />
                </T.Mesh>
              {:else if item.model === "Cylinder"}
                <T.Mesh rotation={[Math.PI / 6, 0, 0]}>
                  <T.CylinderGeometry args={[0.5, 0.5, 1.5, 32]} />
                  <T.MeshStandardMaterial color={item.color} />
                </T.Mesh>
              {:else if item.model === "Cone"}
                <T.Mesh rotation={[Math.PI / 6, 0, 0]}>
                  <T.ConeGeometry args={[0.7, 1.5, 32]} />
                  <T.MeshStandardMaterial color={item.color} />
                </T.Mesh>
              {/if}
            </T.Group>
          {/each}
        </T.Group>
      </Canvas>
    </div>
  </div>

  <div class="descriptions-container">
    {#each items as item, i}
      <div
        class="description-panel"
        style="transform: translateY({(i - indexTween.current) * 100}vh);"
      >
        <h2>{item.name}</h2>
        <p>{item.description}</p>
      </div>
    {/each}
  </div>
</div>

<style>
  .container {
    display: flex;
    width: 100%;
    height: 100vh;
    position: fixed;
    top: 0;
    left: 0;
  }

  .model-container {
    flex: 1;
    position: relative;
    background-color: #f5f5f5;
  }

  .canvas-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
  }

  .descriptions-container {
    flex: 1;
    position: relative;
    overflow: hidden;
    background-color: #2c3a47;
    color: white;
  }

  .description-panel {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100vh;
    padding: 2rem;
    /* Remove the explicit transition, as tweened handles it */
    /* transition: transform 0.6s cubic-bezier(0.16, 1, 0.3, 1); */
    display: flex;
    flex-direction: column;
    justify-content: center;
  }

  h2 {
    font-size: 3rem;
    margin-bottom: 1rem;
    color: #f1f1f1;
  }

  p {
    font-size: 1.2rem;
    line-height: 1.6;
    max-width: 600px;
  }

  /* Add this to create scroll space for all items */
  :global(body) {
    height: 500vh; /* 5 items x 100vh */
    margin: 0;
    padding: 0;
  }
</style>
